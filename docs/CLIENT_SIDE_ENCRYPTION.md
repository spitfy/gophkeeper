# Client-Side Encryption Implementation

## Обзор

В проекте GophKeeper реализовано **end-to-end шифрование на стороне клиента**. Это означает, что все чувствительные данные шифруются на клиенте перед отправкой на сервер и расшифровываются только на клиенте при получении.

## Архитектура шифрования

### Ключевые компоненты

1. **Master Key Manager** ([`internal/app/client/crypto/master_key.go`](../internal/app/client/crypto/master_key.go))
   - Управляет мастер-ключом пользователя
   - Генерирует ключ из пароля пользователя с использованием PBKDF2
   - Хранит зашифрованный мастер-ключ на диске

2. **Record Encryptor** ([`internal/app/client/crypto/encryption.go`](../internal/app/client/crypto/encryption.go))
   - Шифрует/расшифровывает данные записей
   - Использует AES-256-GCM для шифрования
   - Генерирует уникальный nonce для каждой операции шифрования

3. **Encryption Helper** ([`internal/app/client/encryption_helper.go`](../internal/app/client/encryption_helper.go))
   - Вспомогательные функции для работы с шифрованием
   - Подготовка зашифрованных записей для отправки на сервер
   - Расшифровка данных, полученных с сервера

## Процесс шифрования

### 1. Инициализация мастер-ключа

```bash
# Пользователь создает мастер-ключ при первом запуске
gophkeeper init
```

Процесс:
1. Пользователь вводит мастер-пароль
2. Из пароля генерируется 256-битный ключ с использованием PBKDF2
3. Ключ шифруется и сохраняется в файл `~/.gophkeeper/master.key`
4. Хэш ключа сохраняется для проверки при разблокировке

### 2. Создание записи

```bash
# Пользователь создает запись (например, логин/пароль)
gophkeeper record create --type password
```

Процесс:
1. Пользователь вводит данные (логин, пароль, заметки)
2. Данные сериализуются в JSON
3. JSON шифруется с использованием мастер-ключа (AES-256-GCM)
4. Зашифрованные данные кодируются в base64
5. Метаданные (название, категория, теги) остаются незашифрованными для поиска
6. Запись отправляется на сервер через generic API endpoint

**Код:**
```go
// internal/app/client/client.go
func (a *App) CreateLoginRecord(ctx context.Context, req CreateLoginRequest) (int, error) {
    // Подготавливаем метаданные (не шифруем для поиска)
    meta := map[string]interface{}{
        "title":    req.Title,
        "resource": req.Resource,
        "category": req.Category,
        "tags":     req.Tags,
    }
    metaJSON, _ := json.Marshal(meta)

    // Подготавливаем зашифрованную запись
    encryptedReq, err := a.prepareEncryptedRecord(record.RecTypeLogin, req, metaJSON)
    if err != nil {
        return 0, fmt.Errorf("ошибка подготовки зашифрованной записи: %w", err)
    }

    // Отправляем на сервер через generic API
    serverID, err := a.httpClient.CreateRecord(ctx, encryptedReq)
    // ...
}
```

### 3. Получение и расшифровка записи

```bash
# Пользователь получает запись с расшифровкой
gophkeeper record get 123 --decrypt
```

Процесс:
1. Запись загружается с сервера (данные в зашифрованном виде)
2. Зашифрованные данные декодируются из base64
3. Данные расшифровываются с использованием мастер-ключа
4. JSON десериализуется в структуру данных
5. Данные отображаются пользователю

**Код:**
```go
// internal/app/client/encryption_helper.go
func (a *App) decryptRecordData(encryptedData string, target interface{}) error {
    // Декодируем из base64
    encrypted, err := base64.StdEncoding.DecodeString(encryptedData)
    if err != nil {
        return fmt.Errorf("ошибка декодирования base64: %w", err)
    }

    // Расшифровываем данные
    decryptedData, err := a.encryptor.DecryptRecord(encrypted)
    if err != nil {
        return fmt.Errorf("ошибка расшифровки данных: %w", err)
    }

    // Десериализуем JSON
    if err := json.Unmarshal(decryptedData, target); err != nil {
        return fmt.Errorf("ошибка десериализации данных: %w", err)
    }

    return nil
}
```

## Синхронизация

При синхронизации между устройствами:

1. **Загрузка на сервер:**
   - Данные уже зашифрованы на клиенте
   - Сервер получает и хранит зашифрованные данные
   - Сервер не имеет доступа к мастер-ключу

2. **Скачивание с сервера:**
   - Клиент получает зашифрованные данные
   - Расшифровка происходит только на клиенте
   - Требуется разблокированный мастер-ключ

**Код:**
```go
// internal/app/client/sync.go
func (s *SyncService) uploadChanges(ctx context.Context, changes []*LocalRecord) (int, []SyncError) {
    // Данные уже зашифрованы на клиенте, просто передаем их
    for _, rec := range changes {
        syncRec := sync.RecordSync{
            EncryptedData: rec.EncryptedData, // Зашифрованные данные
            Meta:          rec.Meta,          // Метаданные (не шифруются)
            // ...
        }
        syncRecords = append(syncRecords, syncRec)
    }
    // ...
}
```

## Безопасность

### Что шифруется:
- ✅ Логины и пароли
- ✅ Содержимое текстовых заметок
- ✅ Данные банковских карт (номер, CVV, PIN)
- ✅ Бинарные файлы

### Что НЕ шифруется:
- ❌ Метаданные (название, категория, теги) - для возможности поиска
- ❌ Тип записи
- ❌ Дата создания/изменения
- ❌ ID записи

### Криптографические параметры:

- **Алгоритм шифрования:** AES-256-GCM
- **Генерация ключа:** PBKDF2 с SHA-256
- **Итерации PBKDF2:** 100,000
- **Длина ключа:** 256 бит
- **Длина nonce:** 12 байт (96 бит)
- **Длина соли:** 32 байта

## Хранение на сервере

Сервер хранит данные в следующем формате:

```sql
CREATE TABLE records (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,
    type VARCHAR(20) NOT NULL,
    encrypted_data TEXT,  -- Зашифрованные данные в base64
    meta JSONB,           -- Незашифрованные метаданные
    version INTEGER DEFAULT 1,
    last_modified TIMESTAMP DEFAULT NOW(),
    checksum VARCHAR(64),
    device_id VARCHAR(255)
);
```

**Важно:** Сервер никогда не имеет доступа к:
- Мастер-ключу пользователя
- Расшифрованным данным
- Паролю пользователя для мастер-ключа

## Примеры использования

### Создание зашифрованной записи логина

```bash
# 1. Разблокируем мастер-ключ
gophkeeper unlock

# 2. Создаем запись (данные автоматически шифруются)
gophkeeper record create --type password \
    --name "GitHub Account" \
    --username "myuser" \
    --password "secret123" \
    --url "https://github.com"
```

### Просмотр зашифрованной записи

```bash
# Без расшифровки (показывает только метаданные)
gophkeeper record get 123

# С расшифровкой (требует разблокированный мастер-ключ)
gophkeeper record get 123 --decrypt

# С расшифровкой и показом паролей
gophkeeper record get 123 --decrypt --show-password
```

### Синхронизация зашифрованных данных

```bash
# Синхронизация автоматически работает с зашифрованными данными
gophkeeper sync
```

## Восстановление доступа

### Если забыт мастер-пароль:

⚠️ **ВАЖНО:** Если пользователь забыл мастер-пароль, восстановление данных **невозможно**. Это фундаментальное свойство end-to-end шифрования.

Рекомендации:
1. Храните мастер-пароль в надежном месте
2. Используйте менеджер паролей для хранения мастер-пароля
3. Создайте резервную копию мастер-ключа (`~/.gophkeeper/master.key`)

### Смена мастер-пароля:

```bash
gophkeeper auth change-password
```

Процесс:
1. Пользователь вводит старый мастер-пароль
2. Вводит новый мастер-пароль
3. Все локальные данные перешифровываются с новым ключом
4. Новый ключ сохраняется

## Диаграмма потока данных

```
┌─────────────┐                    ┌─────────────┐                    ┌─────────────┐
│   Клиент    │                    │   Сервер    │                    │   Клиент    │
│  (Устр. 1)  │                    │             │                    │  (Устр. 2)  │
└──────┬──────┘                    └──────┬──────┘                    └──────┬──────┘
       │                                  │                                  │
       │ 1. Ввод данных                   │                                  │
       │    (логин/пароль)                │                                  │
       │                                  │                                  │
       │ 2. Шифрование                    │                                  │
       │    AES-256-GCM                   │                                  │
       │    с мастер-ключом               │                                  │
       │                                  │                                  │
       │ 3. POST /api/records             │                                  │
       │    {encrypted_data: "base64..."}│                                  │
       ├─────────────────────────────────>│                                  │
       │                                  │                                  │
       │                                  │ 4. Сохранение                    │
       │                                  │    зашифрованных                 │
       │                                  │    данных в БД                   │
       │                                  │                                  │
       │                                  │ 5. GET /api/records              │
       │                                  │<─────────────────────────────────┤
       │                                  │                                  │
       │                                  │ 6. Возврат                       │
       │                                  │    зашифрованных                 │
       │                                  │    данных                        │
       │                                  ├─────────────────────────────────>│
       │                                  │                                  │
       │                                  │                                  │ 7. Расшифровка
       │                                  │                                  │    с мастер-ключом
       │                                  │                                  │
       │                                  │                                  │ 8. Отображение
       │                                  │                                  │    пользователю
```

## Заключение

Реализация client-side encryption в GophKeeper обеспечивает:

✅ **Zero-knowledge архитектуру** - сервер не знает содержимое данных  
✅ **End-to-end шифрование** - данные шифруются на клиенте и расшифровываются только на клиенте  
✅ **Безопасность при компрометации сервера** - даже при взломе сервера данные остаются зашифрованными  
✅ **Синхронизацию между устройствами** - с сохранением безопасности  
✅ **Локальное хранение** - данные хранятся зашифрованными и локально  

⚠️ **Важно помнить:** Безопасность системы полностью зависит от надежности мастер-пароля пользователя.
